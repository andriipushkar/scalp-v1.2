# Покроковий план реалізації проєкту "QuantumTrader"

Цей документ є дорожньою картою (Roadmap) для розробки проєкту. Він розбитий на логічні етапи (фази), кожен з яких має конкретні завдання та цілі.

## Фаза 1: Створення фундаменту (Дні 1-2)

**Мета:** Підготувати робоче середовище та структуру проєкту. Наприкінці цього етапу у нас буде порожній, але готовий до розробки проєкт.

*   **Крок 1: Налаштування середовища розробки**
    *   Створити новий репозиторій Git (`git init`).
    *   Налаштувати віртуальне середовище Python (`python3 -m venv .venv`).
    *   Створити файл `requirements.txt` та додати до нього основні залежності:
        ```
        python-binance
        pandas
        pandas-ta
        loguru
        asyncio
        websockets
        python-dotenv
        ```
    *   Створити файл `.gitignore`, щоб виключити з репозиторію віртуальне середовище, файли `.env`, логи та інші тимчасові файли.
    *   Створити файл `.env.example` для зберігання списку необхідних змінних середовища (API ключів).

*   **Крок 2: Створення структури проєкту**
    *   Створити всі папки та порожні `__init__.py` файли, як описано в технічній документації: `/configs`, `/core`, `/strategies`, `/analysis`, `/logs`.
    *   Створити порожні файли для основних класів: `main.py`, `core/binance_client.py`, `analysis/technical_analyzer.py` і т.д.

*   **Крок 3: Налаштування конфігурації та логування**
    *   Створити файли `configs/main_config.json` та `configs/strategies.json` зі структурою, описаною в документації.
    *   Налаштувати базову конфігурацію `loguru` в `main.py` для виведення логів у консоль та файл.

## Фаза 2: Розробка ядра (Дні 3-5)

**Мета:** Реалізувати ключові компоненти, відповідальні за отримання даних та аналітику. Наприкінці етапу у нас будуть готові інструменти для роботи з ринковими даними.

*   **Крок 4: Реалізація BinanceClient (`core/binance_client.py`)**
    *   Реалізувати клас `BinanceClient`.
    *   Додати асинхронний метод `get_historical_klines` для завантаження історичних свічок та їх перетворення у `pandas.DataFrame`.
    *   Додати асинхронний метод `connect_kline_socket` для підключення до WebSocket та отримання свічок у реальному часі.

*   **Крок 5: Реалізація аналітичних інструментів (`analysis/`)**
    *   В `analysis/technical_analyzer.py` реалізувати клас `TechnicalAnalyzer` зі статичними методами для розрахунку основних індикаторів (`add_ema`, `add_rsi`, `add_macd`), використовуючи `pandas-ta`.
    *   В `analysis/risk_manager.py` реалізувати клас `RiskManager` зі статичним методом `calculate_position_size`.

## Фаза 3: Реалізація першої стратегії (Дні 6-7)

**Мета:** Створити та протестувати першу торгову стратегію, щоб отримати робочий прототип, який генерує сигнали.

*   **Крок 6: Створення базового класу стратегії (`strategies/base_strategy.py`)**
    *   Створити абстрактний клас `BaseStrategy` з абстрактними методами `check_signal` та `calculate_sl_tp`.

*   **Крок 7: Реалізація EMARibbonScalping (`strategies/scalping/ema_ribbon.py`)**
    *   Створити клас `EMARibbonScalping`, що успадковується від `BaseStrategy`.
    *   Реалізувати логіку `check_signal` та `calculate_sl_tp` відповідно до технічної документації.

## Фаза 4: Оркестрація та запуск (Дні 8-9)

**Мета:** З'єднати всі компоненти разом, щоб бот міг запуститися, отримувати дані, аналізувати їх та генерувати сигнали в логах.

*   **Крок 8: Реалізація DataManager (`core/data_manager.py`)**
    *   Реалізувати клас `DataManager`, який буде завантажувати історичні дані та оновлювати їх за допомогою WebSocket-з'єднання.

*   **Крок 9: Реалізація BotOrchestrator (`core/bot_orchestrator.py`)**
    *   Реалізувати головний клас `BotOrchestrator`, який:
        *   Читає конфігурації.
        *   Динамічно завантажує та ініціалізує класи стратегій.
        *   Створює та запускає `StrategyExecutor` для кожної активної стратегії.

*   **Крок 10: Перший запуск**
    *   Зібрати все в `main.py`.
    *   Запустити бота. Очікуваний результат: у логах з'являються повідомлення про отримання нових свічок та, за сприятливих ринкових умов, згенеровані торгові сигнали від стратегії `EMARibbonScalping`.

## Фаза 5: Розширення функціоналу (Дні 10-14)

**Мета:** Розширити бібліотеку стратегій та додати критично важливі функції для надійності.

*   **Крок 11: Додавання нових стратегій**
    *   Послідовно реалізувати ще 3-4 стратегії з бібліотеки (наприклад, `MACrossover`, `RSICrossover`, `BollingerBandsBreakout`).
    *   Додати їхні конфігурації до `strategies.json`.

*   **Крок 12: Реалізація управління станом (StateManager)**
    *   Створити простий `StateManager`, який зберігає інформацію про відкриті угоди у файл SQLite.
    *   Інтегрувати його в `StrategyExecutor` для запису стану та в `BotOrchestrator` для відновлення при запуску.

## Фаза 6: Тестування та розгортання (Дні 15-20)

**Мета:** Забезпечити якість коду та підготувати проєкт до роботи на сервері.

*   **Крок 13: Написання тестів**
    *   Написати юніт-тести для `RiskManager` та логіки сигналів у кількох стратегіях.
    *   Провести системне тестування на Testnet Binance.

*   **Крок 14: Розробка модуля бектестування**
    *   Створити окремий скрипт для бектестування, який завантажує історичні дані та "проганяє" по них логіку стратегії, враховуючи комісії та прослизання.

*   **Крок 15: Контейнеризація (Docker)**
    *   Написати `Dockerfile` та `docker-compose.yml` для проєкту.

## Фаза 7: Запуск та майбутній розвиток (День 21+)
Ось детальний, покроковий план реалізації проєкту "QuantumTrader", розроблений як практичний посібник для програміста від першого дня роботи до запуску.

Покроковий план реалізації проєкту "QuantumTrader"

Цей документ є дорожньою картою (Roadmap) для розробки проєкту. Він розбитий на логічні етапи (фази), кожен з яких має конкретні завдання та цілі.

Фаза 1: Створення фундаменту (Дні 1-2)

Мета: Підготувати робоче середовище та структуру проєкту. Наприкінці цього етапу у нас буде порожній, але готовий до розробки проєкт.

    Крок 1: Налаштування середовища розробки

        Створити новий репозиторій Git (git init).

        Налаштувати віртуальне середовище Python (python3 -m venv .venv).

        Створити файл requirements.txt та додати до нього основні залежності:

        python-binance
        pandas
        pandas-ta
        loguru
        asyncio
        websockets
        python-dotenv

        Створити файл .gitignore, щоб виключити з репозиторію віртуальне середовище, файли .env, логи та інші тимчасові файли.

        Створити файл .env.example для зберігання списку необхідних змінних середовища (API ключів).

    Крок 2: Створення структури проєкту

        Створити всі папки та порожні __init__.py файли, як описано в технічній документації: /configs, /core, /strategies, /analysis, /logs.

        Створити порожні файли для основних класів: main.py, core/binance_client.py, analysis/technical_analyzer.py і т.д.

    Крок 3: Налаштування конфігурації та логування

        Створити файли configs/main_config.json та configs/strategies.json зі структурою, описаною в документації.

        Налаштувати базову конфігурацію loguru в main.py для виведення логів у консоль та файл.

Фаза 2: Розробка ядра (Дні 3-5)

Мета: Реалізувати ключові компоненти, відповідальні за отримання даних та аналітику. Наприкінці етапу у нас будуть готові інструменти для роботи з ринковими даними.

    Крок 4: Реалізація BinanceClient (core/binance_client.py)

        Реалізувати клас BinanceClient.

        Додати асинхронний метод get_historical_klines для завантаження історичних свічок та їх перетворення у pandas.DataFrame.

        Додати асинхронний метод connect_kline_socket для підключення до WebSocket та отримання свічок у реальному часі.

    Крок 5: Реалізація аналітичних інструментів (analysis/)

        В analysis/technical_analyzer.py реалізувати клас TechnicalAnalyzer зі статичними методами для розрахунку основних індикаторів (add_ema, add_rsi, add_macd), використовуючи pandas-ta.

        В analysis/risk_manager.py реалізувати клас RiskManager зі статичним методом calculate_position_size.

Фаза 3: Реалізація першої стратегії (Дні 6-7)

Мета: Створити та протестувати першу торгову стратегію, щоб отримати робочий прототип, який генерує сигнали.

    Крок 6: Створення базового класу стратегії (strategies/base_strategy.py)

        Створити абстрактний клас BaseStrategy з абстрактними методами check_signal та calculate_sl_tp.

    Крок 7: Реалізація EMARibbonScalping (strategies/scalping/ema_ribbon.py)

        Створити клас EMARibbonScalping, що успадковується від BaseStrategy.

        Реалізувати логіку check_signal та calculate_sl_tp відповідно до технічної документації.

Фаза 4: Оркестрація та запуск (Дні 8-9)

Мета: З'єднати всі компоненти разом, щоб бот міг запуститися, отримувати дані, аналізувати їх та генерувати сигнали в логах.

    Крок 8: Реалізація DataManager (core/data_manager.py)

        Реалізувати клас DataManager, який буде завантажувати історичні дані та оновлювати їх за допомогою WebSocket-з'єднання.

    Крок 9: Реалізація BotOrchestrator (core/bot_orchestrator.py)

        Реалізувати головний клас BotOrchestrator, який:

            Читає конфігурації.

            Динамічно завантажує та ініціалізує класи стратегій.

            Створює та запускає StrategyExecutor для кожної активної стратегії.

    Крок 10: Перший запуск

        Зібрати все в main.py.

        Запустити бота. Очікуваний результат: у логах з'являються повідомлення про отримання нових свічок та, за сприятливих ринкових умов, згенеровані торгові сигнали від стратегії EMARibbonScalping.

Фаза 5: Розширення функціоналу (Дні 10-14)

Мета: Розширити бібліотеку стратегій та додати критично важливі функції для надійності.

    Крок 11: Додавання нових стратегій

        Послідовно реалізувати ще 3-4 стратегії з бібліотеки (наприклад, MACrossover, RSICrossover, BollingerBandsBreakout).

        Додати їхні конфігурації до strategies.json.

    Крок 12: Реалізація управління станом (StateManager)

        Створити простий StateManager, який зберігає інформацію про відкриті угоди у файл SQLite.

        Інтегрувати його в StrategyExecutor для запису стану та в BotOrchestrator для відновлення при запуску.

Фаза 6: Тестування та розгортання (Дні 15-20)

Мета: Забезпечити якість коду та підготувати проєкт до роботи на сервері.

    Крок 13: Написання тестів

        Написати юніт-тести для RiskManager та логіки сигналів у кількох стратегіях.

        Провести системне тестування на Testnet Binance.

    Крок 14: Розробка модуля бектестування

        Створити окремий скрипт для бектестування, який завантажує історичні дані та "проганяє" по них логіку стратегії, враховуючи комісії та прослизання.

    Крок 15: Контейнеризація (Docker)

        Написати Dockerfile та docker-compose.yml для проєкту.

Фаза 7: Запуск та майбутній розвиток (День 21+)

Мета: Запустити бота в реальну роботу та планувати подальший розвиток.

    Крок 16: Реалізація виконання ордерів

        Додати в BinanceClient методи для розміщення та скасування ордерів.

        Інтегрувати логіку виконання угод в StrategyExecutor. Важливо: на цьому етапі додати перемикач "dry-run" (симуляція) / "live" (реальна торгівля).

    Крок 17: Перший запуск "вживу"

        Розгорнути Docker-контейнер на хмарному сервері (VPS/VDS).

        Запустити бота в режимі реальної торгівлі на невеликій сумі для моніторингу.

    Крок 18: Подальший розвиток

        Реалізувати решту стратегій.

        Створити веб-дашборд для моніторингу.

        Працювати над іншими пунктами з розділу "Майбутні вдосконалення".
**Мета:** Запустити бота в реальну роботу та планувати подальший розвиток.

*   **Крок 16: Реалізація виконання ордерів**
    *   Додати в `BinanceClient` методи для розміщення та скасування ордерів.
    *   Інтегрувати логіку виконання угод в `StrategyExecutor`. Важливо: на цьому етапі додати перемикач "dry-run" (симуляція) / "live" (реальна торгівля).

*   **Крок 17: Перший запуск "вживу"**
    *   Розгорнути Docker-контейнер на хмарному сервері (VPS/VDS).
    *   Запустити бота в режимі реальної торгівлі на невеликій сумі для моніторингу.

*   **Крок 18: Подальший розвиток**
    *   Реалізувати решту стратегій.
    *   Створити веб-дашборд для моніторингу.
    *   Працювати над іншими пунктами з розділу "Майбутні вдосконалення".
