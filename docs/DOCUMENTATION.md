# Документація проекту QuantumTrader

## 1. Огляд проекту

**QuantumTrader** — це автоматизований торговий бот, призначений для високочастотного скальпінгу на ринку криптовалютних ф'ючерсів біржі Binance. Бот використовує асинхронну архітектуру для обробки ринкових даних в реальному часі та реалізує стратегії, засновані на аналізі потоку ордерів (Order Flow).

Основна мета — ідентифікація короткострокових ринкових неефективностей та їх використання для отримання прибутку.

## 2. Архітектура

Проект побудований на модульній та асинхронній архітектурі, що забезпечує високу продуктивність та легкість розширення.

![Архітектура](https://i.imgur.com/your_diagram_link.png) 

**Ключові компоненти:**

- **`BotOrchestrator`**: "Мозок" системи. Керує всіма процесами: від вибору торгових пар до управління життєвим циклом угод.
- **`BinanceClient`**: Асинхронний клієнт для взаємодії з REST API та WebSocket потоками Binance.
- **`SymbolScreener`**: Модуль для динамічного відбору найбільш ліквідних торгових інструментів.
- **`OrderBookManager`**: Локальне представлення біржового стакану для кожної торгової пари, що синхронізується в реальному часі.
- **`TradeExecutor`**: Виконує торгові сигнали, що надходять від стратегій, розраховує розмір позиції та керує ордерами.
- **`PositionManager`**: Відстежує стан усіх відкритих позицій та зберігає його для відновлення у разі перезапуску.
- **Стратегії (`strategies/`)**: Ізольовані модулі, що містять торгову логіку.

## 3. Структура файлів

```
QuantumTrader/
├─── core/                  # Ядро системи
│    ├─── bot_orchestrator.py   # Головний клас-оркестратор
│    ├─── binance_client.py     # Клієнт для API Binance
│    ├─── orderbook_manager.py  # Управління біржовим стаканом
│    ├─── position_manager.py   # Управління відкритими позиціями
│    ├─── symbol_screener.py    # Відбір торгових пар
│    └─── trade_executor.py     # Виконання угод
├─── strategies/            # Торгові стратегії
│    ├─── base_strategy.py      # Абстрактний клас для стратегій
│    └─── liquidity_hunting_strategy.py # Стратегія "Полювання на ліквідність"
├─── configs/               # Конфігураційні файли
│    ├─── trading_config.json   # Загальні налаштування торгівлі
│    ├─── strategies.json       # Налаштування та активація стратегій
│    └─── liquidity_hunting_params.yaml # Параметри для стратегії
├─── logs/                  # Файли логів
├─── main.py                # Точка входу в додаток
└─── requirements.txt       # Залежності проекту
```

## 4. Детальний опис модулів

### `main.py`

Точка входу в програму. Відповідає за:
1.  Налаштування логера `loguru` для запису в консоль та у файл.
2.  Ініціалізацію та запуск `BotOrchestrator`.
3.  Обробку чистого виходу з програми (Ctrl+C).

### `core/bot_orchestrator.py`

Клас `BotOrchestrator` є центральним вузлом системи.

- **`__init__`**: Завантажує конфігурації, ініціалізує `PositionManager`.
- **`start`**: Основний метод, що запускає всю логіку:
    1.  Ініціалізує `BinanceClient` та `BinanceSocketManager`.
    2.  Запускає `SymbolScreener` для отримання топ-N символів за обсягом.
    3.  Фільтрує та активує стратегії з `strategies.json` для відібраних символів.
    4.  Налаштовує торгове середовище (кредитне плече, тип маржі) для кожного символу.
    5.  Ініціалізує `OrderBookManager` та `TradeExecutor` для кожної активної стратегії.
    6.  Запускає три паралельні асинхронні задачі:
        - `_market_data_listener`: слухає WebSocket-потоки глибини ринку (`@depth`) та оновлює `OrderBookManager`.
        - `_user_data_listener`: слухає потік даних користувача (зміни по ордерах, балансу) та викликає `_handle_user_data_message`.
        - `monitoring_tasks`: запускає моніторинг сигналів для кожного `TradeExecutor`.
- **`_handle_user_data_message`**: Обробляє повідомлення з `user_data_listener`. Це критично важлива функція, яка реагує на виконання ордерів. Наприклад, після виконання ордеру на вхід, вона розраховує та виставляє SL/TP ордери.

### `core/binance_client.py`

Клас `BinanceClient` — це асинхронна обгортка над бібліотекою `python-binance`.

- Надає зручні методи для всіх необхідних API-запитів: отримання інформації про символи, виставлення/скасування ордерів, отримання балансу тощо.
- Використовує асинхронний контекстний менеджер (`__aenter__`, `__aexit__`) для коректного управління сесіями.

### `core/orderbook_manager.py`

Клас `OrderBookManager` підтримує актуальну копію біржового стакану в пам'яті.

- **`initialize_book`**: Ініціалізує стакан початковим "знімком" (snapshot), отриманим через REST API.
- **`process_depth_message`**: Обробляє повідомлення з WebSocket-потоку `@depth` для оновлення стакану в реальному часі.
- Використовує `pandas.DataFrame` для ефективного зберігання та доступу до даних про `bids` та `asks`.

### `core/position_manager.py`

Клас `PositionManager` відповідає за відстеження відкритих позицій.

- **`_load_state`, `_save_state`**: Зберігає стан позицій у `positions_state.json`, що дозволяє відновити роботу бота після збою без втрати даних про відкриті угоди.
- Надає методи для відкриття, закриття та оновлення позицій.

### `core/symbol_screener.py`

Клас `SymbolScreener` реалізує логіку динамічного вибору торгових інструментів.

- **`get_top_symbols_by_volume`**: Робить запит до API, отримує 24-годинну статистику для всіх ф'ючерсних пар та повертає список топ-N символів, відсортованих за обсягом торгів в USDT.

### `core/trade_executor.py`

Клас `TradeExecutor` є сполучною ланкою між стратегією та біржею.

- **`__init__`**: Ініціалізує конкретний екземпляр стратегії.
- **`start_monitoring`**: Основний цикл, який чекає на оновлення стакану і викликає `_check_and_open_position` (якщо позиції немає) або `_handle_position_adjustment` (якщо позиція відкрита).
- **`_open_position`**: Отримавши сигнал від стратегії, цей метод:
    1.  Розраховує розмір позиції на основі ризик-менеджменту (`margin_per_trade_pct`).
    2.  Формує та відправляє ордер на вхід (лімітний або ринковий).
    3.  Реєструє "відкладений" запит на виставлення SL/TP в `BotOrchestrator`.

### `strategies/`

- **`base_strategy.py`**: Абстрактний клас `BaseStrategy`, що визначає інтерфейс для всіх стратегій. Кожна стратегія повинна реалізувати методи `check_signal` та `calculate_sl_tp`.
- **`liquidity_hunting_strategy.py`**: Реалізація стратегії "Полювання на ліквідність".
    - `check_signal`: Аналізує `OrderBookManager` на наявність великих "стін" ліквідності.
    - `calculate_sl_tp`: Розраховує SL/TP на основі ціни "стіни" та параметрів ризику.

## 5. Конфігурація

Гнучкість бота забезпечується трьома основними конфігураційними файлами:

### `configs/trading_config.json`

Містить глобальні налаштування торгівлі та ризик-менеджменту:
- `margin_per_trade_pct`: Відсоток від балансу, що виділяється на одну угоду.
- `leverage`: Кредитне плече.
- `max_active_trades`: Максимальна кількість одночасно відкритих позицій.
- `max_concurrent_symbols`: Максимальна кількість символів для моніторингу.

### `configs/strategies.json`

Масив об'єктів, де кожен об'єкт описує одну стратегію для конкретної торгової пари.
- `strategy_id`: Унікальний ідентифікатор.
- `strategy_name`: Назва класу стратегії.
- `enabled`: `true` або `false` для активації/деактивації.
- `symbol`: Торгова пара.
- `params`: Специфічні параметри для цієї стратегії.

### `configs/liquidity_hunting_params.yaml`

Параметри, специфічні для стратегії `LiquidityHuntingStrategy`.
- `wall_volume_multiplier`: У скільки разів об'єм має перевищувати середній, щоб вважатися "стіною".
- `activation_distance_ticks`: Максимальна відстань до "стіни" для активації сигналу.
- `entry_offset_ticks`: Відступ від "стіни" для виставлення ордеру.
- `risk_reward_ratio`: Цільове співвідношення ризику до прибутку.

## 6. Як запустити

1.  **Встановіть залежності:**
    ```bash
    pip install -r requirements.txt
    ```
2.  **Створіть файл `.env`** в корені проекту та додайте ваші API ключі:
    ```
    BINANCE_API_KEY="your_api_key"
    BINANCE_API_SECRET="your_api_secret"
    ```
3.  **Налаштуйте конфігурації** в папці `configs/` відповідно до вашої торгової стратегії та ризик-профілю.
4.  **Запустіть бота:**
    ```bash
    python main.py
    ```
