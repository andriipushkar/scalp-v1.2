# **Технічне завдання для розробника: MVP "QuantumTrader"**

**Проєкт:** QuantumTrader
**Версія завдання:** 1.0
**Дата:** 8 жовтня 2025 р.

## **1. Загальна мета**

Розробити ядро асинхронного торгового бота "QuantumTrader". Бот підключається до ринкових даних Binance Futures, аналізує їх у реальному часі за заданими скальпінг-стратегіями, генерує торгові сигнали та автоматично виконує угоди.

-----

## **2. Функціональні вимоги**

  * **Підключення до Binance:** Бот підключається до API та WebSocket-стрімів Binance USDⓈ-M Futures.
  * **Управління даними:** Бот завантажує початкову історію ринкових даних (K-лінії) та підтримує її в актуальному стані за допомогою WebSocket.
  * **Реалізація стратегії:** Реалізовано торгову стратегію **"Order Flow Scalping"**.
  * **Генерація сигналів:** На основі логіки стратегії бот ідентифікує точки входу для Long та Short позицій.
  * **Виконання угод:** Бот автоматично відкриває ринкові ордери при отриманні сигналу.
  * **Управління позиціями:** Бот відстежує відкриті позиції, зберігаючи їх стан у файлі `logs/positions_state.json`.
  * **Управління ризиками:** 
      * **Stop-Loss:** Для кожної позиції автоматично виставляється реальний `STOP_MARKET` ордер на біржі.
      * **Take-Profit:** Рівень тейк-профіту відстежується внутрішньо, і при його досягненні позиція закривається ринковим ордером.
  * **Логування:** Усі ключові події, включаючи сигнали, ордери та помилки, записуються в лог-файл.

-----

## **3. Технічні специфікації та компоненти для реалізації**

### **3.1. Структура проєкту (мінімальна)**

```
/QuantumTrader/
├── main.py
├── configs/
│   ├── strategies.json
│   └── trading_config.json
├── core/
│   ├── __init__.py
│   ├── binance_client.py
│   ├── bot_orchestrator.py
│   ├── data_manager.py
│   └── orderflow_manager.py
├── strategies/
│   ├── __init__.py
│   ├── base_strategy.py
│   └── scalping/
│       └── order_flow_scalping.py
├── analysis/
│   ├── __init__.py
│   ├── risk_manager.py
│   └── technical_analyzer.py
└── requirements.txt
```

### **3.2. Компонент `core/binance_client.py`**

  * **Клас:** `BinanceClient`
  * **Основні методи:**
      * `async def get_historical_klines(...)`: Завантажує історичні свічки.
      * `async def get_position_for_symbol(...)`: Отримує інформацію про відкриту позицію для вказаного символу.
      * `async def create_order(...)`: Створює ринковий ордер.
      * `async def create_stop_market_order(...)`: Створює `STOP_MARKET` ордер для стоп-лосу.
      * `async def cancel_order(...)`: Скасовує активний ордер.

### **3.3. Компонент `analysis/technical_analyzer.py`**

  * **Клас:** `TechnicalAnalyzer`
  * **Методи:**
      * `@staticmethod def add_emas(df: pd.DataFrame, periods: list[int]) -> pd.DataFrame:`
          * Приймає DataFrame та список періодів.
          * Додає до DataFrame нові стовпці для кожної EMA (напр., `EMA_20`, `EMA_25` і т.д.).
          * Повертає оновлений DataFrame.

### **3.4. Компонент `strategies/scalping/order_flow_scalping.py`**

  * **Клас:** `OrderFlowScalpingStrategy`, успадкований від `BaseStrategy`.
  * **Логіка `check_signal`:**
      * **Сигнал "Exhaustion" (Виснаження):**
          * `HighVol=True` (Високий об'єм): Об'єм останньої свічки значно вищий за середній. Це може свідчити про кульмінацію руху.
          * `SmallBody=True` (Маленьке тіло свічки): Тіло свічки дуже маленьке, що при великому об'ємі може означати нерішучість ринку.
          * `NewHigh=True` / `NewLow=True` (Новий максимум/мінімум): Ціна оновлює свій максимум (для шорта) або мінімум (для лонга) за останній період.
          * `CVDBearish=True` / `CVDBullish=True` (Ведмежа/бичача дивергенція CVD): Індикатор CVD показує розбіжність з ціною, що свідчить про слабкість поточного тренду.
      * **Сигнал "Absorption" (Поглинання):**
          * `HighVol=True` (Високий об'єм): Високий об'єм торгів.
          * `is_rejection_from_high=True` / `is_rejection_from_low=True` (Відбій від максимуму/мінімуму): Свічка має довгу тінь, що вказує на відбій ціни від рівня.
          * `is_at_high=True` / `is_at_low=True` (На максимумі/мінімумі): Сигнал виникає на локальному максимумі або мінімумі.
          * `CVDBearish=True` / `CVDBullish=True` (Ведмежа/бичача дивергенція CVD): CVD підтверджує сигнал.
  * **Логіка `calculate_sl_tp`:**
      * **Stop-Loss:** Розраховується на основі ціни входу та середнього істинного діапазону (ATR) з використанням множника `sl_atr_multiplier`.
      * **Take-Profit:** Розраховується аналогічно, використовуючи `tp_atr_multiplier`.
      * **Перевірка прибутковості:** Перед відкриттям угоди перевіряється, чи потенційний прибуток перевищує комісійні витрати.

### **3.5. Компонент `core/bot_orchestrator.py`**

  * **Клас `BotOrchestrator`:**
    *   Читає конфігурації з `configs/strategies.json` та `configs/trading_config.json`.
    *   Ініціалізує `BinanceClient`, `PositionManager` та `TradeExecutor` для кожної активної стратегії.
    *   Запускає WebSocket для отримання ринкових даних у реальному часі.
    *   Запускає головний цикл, у якому періодично виконується логіка для кожного `TradeExecutor`.
  * **Клас `TradeExecutor`:**
    *   Відповідає за логіку однієї торгової стратегії для однієї пари.
    *   Перевіряє наявність відкритих позицій.
    *   Якщо позиції немає, шукає нові торгові сигнали від стратегії.
    *   При отриманні сигналу:
        1.  Розраховує розмір позиції, SL/TP.
        2.  Відкриває ринковий ордер.
        3.  Після підтвердження виконання ордера, отримує фактичні дані про позицію.
        4.  Виставляє `STOP_MARKET` ордер на біржі для стоп-лосу.
        5.  Зберігає всю інформацію про позицію, включаючи ID стоп-ордера, у `PositionManager`.
    *   Якщо позиція відкрита, відстежує її, перевіряючи досягнення тейк-профіту або сигналу на розворот.
  * **Клас `PositionManager`:**
    *   Керує станом усіх відкритих позицій.
    *   Зберігає та завантажує стан з файлу `logs/positions_state.json`.
    *   Коректно враховує лише позиції з ненульовою кількістю.

-----

## **4. Формат конфігурації та логів**

### **`configs/strategies.json`**

```json
[
  {
    "strategy_id": "OrderFlowScalping_BTCUSDT_1m",
    "enabled": true,
    "symbol": "BTCUSDT",
    "interval": "1m",
    "parameters": {
      "params_file": "configs/orderflow_params.yaml",
      "params_key": "OrderFlowScalping_BTCUSDT_1m"
    }
  }
]
```

### **`configs/orderflow_params.yaml`**

```yaml
default:
  volume_threshold_multiplier: 2.5
  body_size_threshold_pct: 0.2
  climax_bar_lookback: 10
  tp_atr_multiplier: 1.5
  sl_atr_multiplier: 1.0
  cvd_sma_period: 5
  setups:
    exhaustion_short:
      enabled: true
      conditions:
        # ...
    # ...
```

### **Формат логування сигналу (JSON)**

```json
{
  "timestamp": "2025-10-09T19:51:52.271Z",
  "level": "SUCCESS",
  "message": "[GMTUSDT] Confirmed LONG signal (Absorption) at 0.0372",
  ...
}
```

-----

## **5. Покроковий план виконання**

1.  **Налаштування:** Створити структуру проєкту та налаштувати віртуальне середовище.
2.  **Реалізація `BinanceClient`:** Написати методи для отримання історичних даних та підключення до WebSocket.
3.  **Реалізація `OrderFlowScalpingStrategy`:** Створити `BaseStrategy` та `OrderFlowScalpingStrategy`.
4.  **Реалізація `BotOrchestrator`:** Написати головний цикл програми.
5.  **Тестування:** Запустити бота та перевірити, що він коректно отримує дані та генерує сигнали в лог-файл.

## **6. Критерії приймання**

  * [x] Код написаний згідно зі стандартами PEP8 та містить анотації типів.
  * [x] Проєкт запускається з командного рядка (`python main.py`) без помилок.
  * [x] Бот успішно підключається до Binance та отримує дані.
  * [x] При виникненні умов для входу в угоду в лог-файлі з'являється запис.
  * [x] Бот стабільно працює та не "падає" через необроблені винятки.
